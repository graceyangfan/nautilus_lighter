from __future__ import annotations

# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import ctypes
import json
import os
import platform
import time
from dataclasses import dataclass
from ctypes import c_char_p, c_int, c_longlong, Structure
from pathlib import Path
from typing import Any

from nautilus_trader.common.component import Logger
try:  # optional dependency; keep import at module scope but tolerant
    from eth_account import Account as _EthAccount  # type: ignore
    from eth_account.messages import encode_defunct as _encode_defunct  # type: ignore
except Exception:  # pragma: no cover - optional
    _EthAccount = None  # type: ignore[assignment]
    _encode_defunct = None  # type: ignore[assignment]
from nautilus_trader.adapters.lighter.http.transaction import LighterTransactionHttpClient
from nautilus_trader.adapters.lighter.common.utils import parse_hex_int as _parse_hex_int
from nautilus_trader.adapters.lighter.common.enums import (
    LighterOrderType,
    LighterTimeInForce,
    LighterCancelAllTif,
    LighterMarginMode,
    LighterTxType,
    DEFAULT_IOC_EXPIRY,
    DEFAULT_GTT_EXPIRY,
)


@dataclass
class LighterCredentials:
    """Immutable credentials required by the Lighter signer.

    Attributes
    ----------
    pubkey : str
        The account public key (hex string).
    account_index : int
        The venue account index.
    api_key_index : int
        The index of the API key to use.
    nonce : int | None
        Optional initial nonce; if None the execution client should fetch it.
    private_key : str | None
        The API key private key generated by lighter-go `GenerateAPIKey`.
        Expected format is a 0x-prefixed 80-hex string (40 bytes). Values with
        or without the `0x` prefix are accepted and normalized internally.
    """

    pubkey: str
    account_index: int
    api_key_index: int
    nonce: int | None = None
    private_key: str | None = None

    @staticmethod
    def from_json_file(path: str | os.PathLike[str]) -> "LighterCredentials":
        """Load credentials from a JSON file on disk."""
        data = json.loads(Path(path).read_text(encoding="utf-8"))

        return LighterCredentials(
            pubkey=str(data.get("pubkey")),
            account_index=_parse_hex_int(data.get("account_index")) or 0,
            api_key_index=_parse_hex_int(data.get("api_key_index")) or 0,
            nonce=_parse_hex_int(data.get("nonce")),
            private_key=(data.get("private_key") or None),
        )


class LighterSigner:
    """l­­ighter-go (ctypes) signer wrapper.

    Notes
    -----
    - Credentials are supplied explicitly; no environment fallbacks are used.
    - FFI prototypes are prepared once; API key context switches only when needed.
    - The class is intentionally minimal: prepare context, sign, return payload.
    """

    def __init__(self, credentials: LighterCredentials, base_url: str, chain_id: int | None = None) -> None:
        self._creds = credentials
        # Private key must be provided via credentials
        self._priv = (credentials.private_key or "").strip()
        self._base_url = base_url.rstrip("/")
        self._chain_id = int(chain_id) if chain_id is not None else None
        self._log: Logger = Logger(type(self).__name__)
        # Backend: lighter-go shared library (ctypes)
        self._go = None
        self._init_goffi()
        self._go_ready = False
        # Capability flags populated after prototypes are prepared
        self._has_create_auth_token: bool = False
        self._has_switch_api_key: bool = False
        self._has_sign_modify_order: bool = False
        self._has_sign_update_leverage: bool = False
        self._has_sign_change_pubkey: bool = False
        if self._go is None:
            raise RuntimeError(
                "lighter-go signer library not available. Place the platform-specific signer binary under adapters/lighter/signers/."
            )
        self._prepare_prototypes()
        self._last_api_key_index: int | None = None
        # Debug capability summary
        if os.getenv("LIGHTER_DEBUG") or os.getenv("NAUTILUS_DEBUG"):
            caps = SignerCapabilities(
                create_auth_token=self._has_create_auth_token,
                switch_api_key=self._has_switch_api_key,
                sign_modify_order=self._has_sign_modify_order,
                sign_update_leverage=self._has_sign_update_leverage,
                sign_change_pubkey=self._has_sign_change_pubkey,
            )
            self._log.info(
                "Signer capabilities: "
                f"auth={caps.create_auth_token} "
                f"switch={caps.switch_api_key} "
                f"modify={caps.sign_modify_order} "
                f"leverage={caps.sign_update_leverage} "
                f"change_key={caps.sign_change_pubkey}",
            )

    @property
    def pubkey(self) -> str:
        return self._creds.pubkey

    @property
    def account_index(self) -> int:
        return self._creds.account_index

    @property
    def api_key_index(self) -> int:
        return self._creds.api_key_index

    def create_auth_token(self, deadline_seconds: int = 600) -> str:
        """Create a short-lived auth token using the go signer.

        The lighter-go API expects an absolute deadline timestamp (current_time + expiry_seconds),
        matching lighter-python's ``create_auth_token_with_expiry(deadline_seconds)``.
        """
        import time
        self._go_create_client()
        if not self._has_create_auth_token:
            return ""
        ttl = int(deadline_seconds if deadline_seconds and deadline_seconds > 0 else 600)
        # Pass absolute timestamp (current_time + ttl) to match lighter-python behavior
        deadline_timestamp = int(time.time()) + ttl
        res = self._go.CreateAuthToken(deadline_timestamp)
        tok = _decode_str(res.str)
        err = _decode_str(res.err)
        return tok or ""

    def available(self) -> bool:
        # Available only if go-ffi is loaded
        return bool(self._go)

    # External signer command support removed; lighter-go is the only backend

    # ---- lighter-go (ctypes) backend -------------------------------------------------------
    def _init_goffi(self) -> None:
        """Load the platform-specific lighter-go shared library.

        Load order:
        1) Environment override ``LIGHTER_SIGNER_LIB``
        2) Packaged binary under ``adapters/lighter/signers/``
        """
        # 1) Env override
        override = os.getenv("LIGHTER_SIGNER_LIB")
        if override:
            p = Path(override)
            if p.exists():
                try:
                    self._go = ctypes.CDLL(str(p))
                    return
                except Exception:
                    self._go = None
        # 2) Packaged
        base_dir = Path(__file__).resolve().parent.parent / "signers"
        sysname = platform.system()
        machine = platform.machine().lower()
        candidate = self._candidate_path_for(sysname, machine, base_dir)
        if candidate and candidate.exists():
            self._go = ctypes.CDLL(str(candidate))
            return
        self._go = None

    @staticmethod
    def _candidate_path_for(sysname: str, machine_lower: str, base: Path | None) -> Path | None:
        if base is None:
            return None
        if sysname == "Darwin" and machine_lower == "arm64":
            # Preferred name used by this adapter
            cand = base / "signer-arm64.dylib"
            if cand.exists():
                return cand
            # Fallback to official lighter-python naming
            alt = base / "lighter-signer-darwin-arm64.dylib"
            return alt if alt.exists() else cand
        if sysname == "Linux" and machine_lower in ("x86_64", "amd64"):
            cand = base / "signer-amd64.so"
            if cand.exists():
                return cand
            alt = base / "lighter-signer-linux-amd64.so"
            return alt if alt.exists() else cand
        if sysname == "Linux" and machine_lower == "arm64":
            cand = base / "signer-arm64.so"
            if cand.exists():
                return cand
            alt = base / "lighter-signer-linux-arm64.so"
            return alt if alt.exists() else cand
        if sysname == "Windows" and machine_lower in ("x86_64", "amd64"):
            cand = base / "signer-amd64.dll"
            if cand.exists():
                return cand
            alt = base / "lighter-signer-windows-amd64.dll"
            return alt if alt.exists() else cand
        return None

    # No network auto-download; signer library must be present under packaged signers/

    def _prepare_prototypes(self) -> None:
        """Bind ctypes prototypes for the required lighter-go functions."""
        if not self._go:
            return
        # CreateClient(url, api_key_pk, chain_id, api_key_index, account_index)
        self._go.CreateClient.argtypes = [c_char_p, c_char_p, c_int, c_int, c_longlong]
        self._go.CreateClient.restype = c_char_p
        # Optional
        if hasattr(self._go, "CreateAuthToken"):
            self._go.CreateAuthToken.argtypes = [c_longlong]
            self._go.CreateAuthToken.restype = _StrOrErr
            self._has_create_auth_token = True
        # Switch key
        if hasattr(self._go, "SwitchAPIKey"):
            self._go.SwitchAPIKey.argtypes = [c_int]
            self._go.SwitchAPIKey.restype = c_char_p
            self._has_switch_api_key = True
        # Signatures
        # SignCreateOrder (match lighter-python signer_client.py):
        #   market_index: c_int,
        #   client_order_index: c_longlong,
        #   base_amount: c_longlong,
        #   price: c_longlong,         # use 64-bit to avoid overflow/signature mismatch
        #   is_ask: c_int,
        #   order_type: c_int,
        #   time_in_force: c_int,
        #   reduce_only: c_int,
        #   trigger_price: c_longlong, # use 64-bit
        #   order_expiry: c_longlong,
        #   nonce: c_longlong
        self._go.SignCreateOrder.argtypes = [
            c_int,
            c_longlong,
            c_longlong,
            c_longlong,
            c_int,
            c_int,
            c_int,
            c_int,
            c_longlong,
            c_longlong,
            c_longlong,
        ]
        self._go.SignCreateOrder.restype = _StrOrErr
        self._go.SignCancelAllOrders.argtypes = [c_int, c_longlong, c_longlong]
        self._go.SignCancelAllOrders.restype = _StrOrErr
        self._go.SignCancelOrder.argtypes = [c_int, c_longlong, c_longlong]
        self._go.SignCancelOrder.restype = _StrOrErr
        if hasattr(self._go, "SignModifyOrder"):
            self._go.SignModifyOrder.argtypes = [c_int, c_longlong, c_longlong, c_longlong, c_longlong, c_longlong]
            self._go.SignModifyOrder.restype = _StrOrErr
            self._has_sign_modify_order = True
        if hasattr(self._go, "SignUpdateLeverage"):
            self._go.SignUpdateLeverage.argtypes = [c_int, c_int, c_int, c_longlong]
            self._go.SignUpdateLeverage.restype = _StrOrErr
            self._has_sign_update_leverage = True
        # Change API key (returns tx_info with MessageToSign)
        if hasattr(self._go, "SignChangePubKey"):
            self._go.SignChangePubKey.argtypes = [c_char_p, c_longlong]
            self._go.SignChangePubKey.restype = _StrOrErr
            self._has_sign_change_pubkey = True

    def _ensure_api_key_context(self) -> None:
        """Switch the signer context to the configured API key (if changed)."""
        idx = self._creds.api_key_index
        if self._last_api_key_index == idx:
            return
        if self._has_switch_api_key:
            _ = self._go.SwitchAPIKey(idx)
        self._last_api_key_index = idx

    def _go_sign_create_order(self, market_index: int, client_order_index: int, base_amount: int, price: int, is_ask: bool, order_type: int, time_in_force: int, reduce_only: bool, trigger_price: int, order_expiry: int, nonce: int | None) -> tuple[str | None, str | None]:
        self._go_create_client()
        self._ensure_api_key_context()
        res = self._go.SignCreateOrder(
            int(market_index),
            int(client_order_index),
            int(base_amount),
            int(price),
            int(1 if is_ask else 0),
            int(order_type),
            int(time_in_force),
            int(1 if reduce_only else 0),
            int(trigger_price),
            int(order_expiry),
            int(-1 if nonce is None else nonce),
        )
        s = _decode_str(res.str)
        e = _decode_str(res.err)
        return (s, e)

    # Alt variant no longer needed when argtypes and ordering match lighter-python

    def _go_sign_cancel_all(self, time_in_force: int, time: int, nonce: int | None) -> tuple[str | None, str | None]:
        self._go_create_client()
        self._ensure_api_key_context()
        res = self._go.SignCancelAllOrders(time_in_force, time, (-1 if nonce is None else nonce))
        s = _decode_str(res.str)
        e = _decode_str(res.err)
        return (s, e)

    def _go_sign_cancel_order(self, market_index: int, order_index: int, nonce: int | None) -> tuple[str | None, str | None]:
        self._go_create_client()
        self._ensure_api_key_context()
        res = self._go.SignCancelOrder(market_index, order_index, (-1 if nonce is None else nonce))
        s = _decode_str(res.str)
        e = _decode_str(res.err)
        return (s, e)

    def _go_sign_modify_order(self, market_index: int, order_index: int, base_amount: int, price: int, trigger_price: int, nonce: int | None) -> tuple[str | None, str | None]:
        self._go_create_client()
        self._ensure_api_key_context()
        if not self._has_sign_modify_order:
            return None, "SignModifyOrder not available in signer library"
        res = self._go.SignModifyOrder(
            market_index,
            order_index,
            base_amount,
            price,
            trigger_price,
            (-1 if nonce is None else nonce),
        )
        s = _decode_str(res.str)
        e = _decode_str(res.err)
        return (s, e)

    def _go_sign_update_leverage(self, market_index: int, fraction_bps: int, margin_mode: int, nonce: int | None) -> tuple[str | None, str | None]:
        self._go_create_client()
        self._ensure_api_key_context()
        if not self._has_sign_update_leverage:
            return None, "SignUpdateLeverage not available in signer library"
        res = self._go.SignUpdateLeverage(market_index, fraction_bps, margin_mode, (-1 if nonce is None else nonce))
        s = _decode_str(res.str)
        e = _decode_str(res.err)
        return (s, e)

    def _go_create_client(self) -> None:
        if not self._go or self._go_ready:
            return
        # Chain ID: prefer configured value; else infer from URL
        if self._chain_id is not None:
            chain_id = int(self._chain_id)
        else:
            url_l = (self._base_url or "").lower()
            chain_id = 304 if "mainnet" in url_l else 300
        pk = (self._priv or "")
        if pk.startswith("0x") or pk.startswith("0X"):
            pk = pk[2:]
        err = self._go.CreateClient(
            self._base_url.encode("utf-8"),
            pk.encode("utf-8"),
            chain_id,
            self._creds.api_key_index,
            self._creds.account_index,
        )
        if err is None:
            self._go_ready = True
            return
        err_str = _decode_str(err) or "CreateClient failed (unknown error)"
        # keep _go_ready as False and surface the error
        raise RuntimeError(err_str)

    def get_tx_type_create_order(self) -> int:
        return int(LighterTxType.CREATE_ORDER)

    def get_tx_type_cancel_order(self) -> int:
        return int(LighterTxType.CANCEL_ORDER)

    def get_tx_type_cancel_all(self) -> int:
        return int(LighterTxType.CANCEL_ALL_ORDERS)

    def get_tx_type_modify_order(self) -> int:
        return int(LighterTxType.MODIFY_ORDER)

    def get_tx_type_update_leverage(self) -> int:
        return int(LighterTxType.UPDATE_LEVERAGE)

    def get_tx_type_change_pub_key(self) -> int:
        return int(LighterTxType.CHANGE_PUB_KEY)

    async def sign_create_order_tx(self, market_index: int, client_order_index: int, base_amount: int, price: int, is_ask: bool, order_type: LighterOrderType, time_in_force: LighterTimeInForce, reduce_only: bool, trigger_price: int = 0, order_expiry: int | None = None, nonce: int | None = None) -> tuple[str | None, str | None]:
        """Return (tx_info_json_str, error), consuming Lighter enums only."""
        exp = DEFAULT_IOC_EXPIRY if (order_expiry is None and time_in_force == LighterTimeInForce.IOC) else (
            DEFAULT_GTT_EXPIRY if order_expiry is None else int(order_expiry)
        )
        # lighter-go (ctypes) backend
        ot = order_type.value
        tif = time_in_force.value
        s, e = self._go_sign_create_order(
                market_index=market_index,
                client_order_index=client_order_index,
                base_amount=base_amount,
                price=price,
                is_ask=is_ask,
                order_type=ot,
                time_in_force=tif,
                reduce_only=reduce_only,
                trigger_price=trigger_price,
                order_expiry=exp,
                nonce=nonce,
        )
        return s, e

    # Removed sign_create_order_tx_alt; default path matches lighter-python

    async def sign_cancel_all_orders_tx(self, time_in_force: LighterCancelAllTif, time: int = 0, nonce: int | None = None) -> tuple[str | None, str | None]:
        tif = time_in_force.value
        s, e = self._go_sign_cancel_all(time_in_force=tif, time=time, nonce=nonce)
        return s, e

    async def sign_cancel_order_tx(self, market_index: int, order_index: int, nonce: int | None = None) -> tuple[str | None, str | None]:
        s, e = self._go_sign_cancel_order(market_index, order_index, nonce)
        return s, e

    async def sign_create_tp_limit_tx(self, market_index: int, client_order_index: int, base_amount: int, tp_price: int, is_ask: bool, reduce_only: bool = True, trigger_price: int | None = None, nonce: int | None = None) -> tuple[str | None, str | None, int]:
        """Return ``(tx_info, error, tx_type)`` using the TAKE_PROFIT_LIMIT variant of ``create_order``."""
        # Use TAKE_PROFIT_LIMIT + GTT for TP-LIMIT flavor
        order_type = LighterOrderType.TAKE_PROFIT_LIMIT.value
        tif = LighterTimeInForce.GTT.value
        s, e = self._go_sign_create_order(
                market_index=market_index,
                client_order_index=client_order_index,
                base_amount=base_amount,
                price=tp_price,
                is_ask=is_ask,
                order_type=order_type,
                time_in_force=tif,
                reduce_only=reduce_only,
                trigger_price=int(trigger_price) if trigger_price is not None else 0,
                order_expiry=DEFAULT_GTT_EXPIRY,
                nonce=nonce,
        )
        return s, e, order_type

    async def sign_modify_order_tx(self, market_index: int, order_index: int, base_amount: int, price: int, trigger_price: int, nonce: int | None = None) -> tuple[str | None, str | None]:
        s, e = self._go_sign_modify_order(market_index, order_index, base_amount, price, trigger_price, nonce)
        return s, e

    async def sign_update_leverage_tx(self, market_index: int, fraction_bps: int, margin_mode: LighterMarginMode, nonce: int | None = None) -> tuple[str | None, str | None]:
        mm = margin_mode.value
        s, e = self._go_sign_update_leverage(market_index, fraction_bps, mm, nonce)
        return s, e

    # ---- Change API key (pubkey) --------------------------------------------------------------
    def _go_sign_change_pubkey(self, new_pubkey_hex: str, nonce: int | None) -> tuple[str | None, str | None]:
        self._go_create_client()
        if not self._has_sign_change_pubkey:
            return None, "SignChangePubKey not available in signer library"
        self._ensure_api_key_context()
        res = self._go.SignChangePubKey(new_pubkey_hex.encode("utf-8"), (-1 if nonce is None else int(nonce)))
        s = _decode_str(res.str)
        e = _decode_str(res.err)
        return (s, e)

    async def sign_change_api_key_tx(self, new_pubkey_hex: str, nonce: int | None = None) -> tuple[str | None, str | None]:
        """Return tx_info JSON (with MessageToSign) and error for ChangePubKey.

        The returned JSON includes ``MessageToSign`` which must be signed using
        the account L1 private key (EIP-191). Use ``change_api_key`` for a
        convenience wrapper which performs the signing and HTTP submission.
        """
        s, e = self._go_sign_change_pubkey(new_pubkey_hex, nonce)
        return s, e

    async def change_api_key(self, eth_private_key: str, new_pubkey_hex: str, nonce: int | None = None) -> tuple[dict | None, str | None]:
        """Change the API key public key on the venue and return (resp, error).

        This method:
        1) Calls the signer FFI to obtain a ChangePubKey tx_info with MessageToSign
        2) Signs MessageToSign using the provided L1 private key (EIP-191)
        3) Submits the signed tx_info via REST POST /api/v1/sendTx

        Returns the decoded REST response (dict) and an error string if any.
        """

        tx_info_str, err = self._go_sign_change_pubkey(new_pubkey_hex, nonce)
        if err:
            return None, err
        if not tx_info_str:
            return None, "empty tx_info from SignChangePubKey"
        tx_info = json.loads(tx_info_str)
        msg = tx_info.get("MessageToSign")
        if not msg:
            return None, "missing MessageToSign in tx_info"
        # Sign using provided L1 private key
        acct = _EthAccount.from_key(eth_private_key)
        sig = acct.sign_message(_encode_defunct(text=str(msg))).signature.to_0x_hex()
        tx_info.pop("MessageToSign", None)
        tx_info["L1Sig"] = sig
        final_tx_info = json.dumps(tx_info)

        # Submit via adapter HTTP client
        http = LighterTransactionHttpClient(self._base_url)
        # Ensure eth-account is available
        if _EthAccount is None or _encode_defunct is None:
            return None, "eth-account unavailable"
        resp = await http.send_tx(tx_type=int(LighterTxType.CHANGE_PUB_KEY), tx_info=final_tx_info, price_protection=None, auth=None)
        return resp, None


# ctypes helpers ---------------------------------------------------------------------------------

class _StrOrErr(Structure):
    _fields_ = [("str", c_char_p), ("err", c_char_p)]


def _decode_str(ptr: bytes | None) -> str | None:
    if not ptr:
        return None
    try:
        return ptr.decode("utf-8")  # type: ignore[attr-defined]
    except Exception:
        try:
            return bytes(ptr).decode("utf-8")  # type: ignore[arg-type]
        except Exception:
            return None
@dataclass(frozen=True)
class SignerCapabilities:
    create_auth_token: bool
    switch_api_key: bool
    sign_modify_order: bool
    sign_update_leverage: bool
    sign_change_pubkey: bool
